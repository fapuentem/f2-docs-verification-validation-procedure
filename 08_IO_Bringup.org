#+TITLE: I/O Visibility — F2 Smart Controller (F2SC01)
#+AUTHOR: Fabricio Puente M.
#+DATE: <2025-10-28 Tue>
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+OPTIONS: toc:t num:t ^:t
#+PROPERTY: header-args :results output :exports both
#+FILETAGS: :F2:CarrierBoard:VnV:IO:Kernel:Detection:GPIO:UART:I2C:SPI:CAN:TPM:Sensors:

* Purpose

Verify that Linux *can see* all F2SC01 low-speed I/O and onboard sensors:
device nodes exist, drivers bind, and key identity registers are readable.
(No extended functional/closed-loop testing here.)

* Scope

- PCB revision ~v3.1.x~ (or as specified)
- Jetson Orin NX (JetPack/L4T 5.1.2)
- After PCIe/USB visibility steps have passed

* Metadata

:PROPERTIES:
:Board-Model:   F2SC01
:PCB-Revision:
:SOM:           Jetson Orin NX (SKU: )
:Serial-Number:
:Lot/WO:
:Operator:
:DATE:
:END:

* Acceptance Criteria

- Kernel logs show controller/sensor probe without critical errors
- Expected nodes appear under */dev* and */sys*
- Basic ID / WHO_AM_I reads match data sheets (where applicable)
- Evidence saved under =evidence/io_visibility/=

* Notes

- Replace bus numbers if your DT assigns different I²C indices.
- Reads use =i2c-tools=; keep them brief and non-destructive.

* Global Kernel Footprint

** Device tree aliases (quick sanity)

#+BEGIN_SRC bash :results output :exports both
  tr -d '\0' </proc/device-tree/model 2>/dev/null || true
  echo "Aliases:"
  # Dump all alias -> target paths
  for f in /proc/device-tree/aliases/*; do
      alias=$(basename "$f")
    target=$(tr -d '\0' <"$f")
    printf "%-8s -> %s\n" "$alias" "$target"
  done
#+END_SRC

* USB Hub & RS-485 Bridge

** USB hub (SMSC/Microchip 0424:2514)

#+BEGIN_SRC bash :results output :exports both
  # Check for Microchip USB 2.0 Hub (VID:PID = 0424:2514)
  if lsusb | grep -qi "0424:2514"; then
    echo "✅ USB Hub 0424:2514 detected (Microchip Technology, Inc.)"
  else
    echo "❌ USB Hub 0424:2514 not found"
  fi
#+END_SRC

** FTDI bridge (0403:6015)  (Battery Monitor @ ttyUSBx)

#+BEGIN_SRC bash :results output :exports both
  # Check for FTDI USB device (VID:PID = 0403:6015)
  if lsusb | grep -qi "0403:6015"; then
    echo "✅ FTDI device 0403:6015 detected"
  else
    echo "❌ FTDI device 0403:6015 not found"
  fi

  # List serial devices associated with FTDI
  if ls /dev/ttyUSB* >/dev/null 2>&1; then
    echo "📂 Serial devices found:"
    ls -l /dev/ttyUSB*
  else
    echo "⚠️ No /dev/ttyUSB* device nodes detected"
  fi
#+END_SRC

** AX210 BT

#+BEGIN_SRC bash :results output :exports both
  # Intel Bluetooth USB interface uses Vendor 8087.
  # Common PIDs seen on AX2xx: 0026, 0029, 0032, 0033, 0035 (not exhaustive).
  if lsusb | grep -qiE "8087:(0026|0029|0032|0033|0035)"; then
    echo "✅ Intel Bluetooth interface detected (VID 8087)"
    # Show which one(s)
    lsusb | awk 'BEGIN{IGNORECASE=1}/8087:(0026|0029|0032|0033|0035)/{print "  • " $0}'
  else
    echo "❌ Intel Bluetooth interface not found (VID 8087 + common AX2xx PIDs)"
  fi
#+END_SRC

** M2 Card Matter
(Matter M2 Card is in development now, so this field was leave in blank on purpose.)

* CAN-BUS (visibility only)

** Kernel modules
#+BEGIN_SRC bash :dir /sudo:: :results output :exports both
  echo "=== Loading CAN kernel modules ==="
  for mod in can can_raw mttcan; do
    if lsmod | grep -qw "$mod"; then
      echo "[OK] Module '$mod' already loaded"
    else
      echo "[..] Loading '$mod'..."
      if sudo modprobe "$mod"; then
        echo "[OK] '$mod' loaded successfully"
      else
        echo "[ERR] Failed to load '$mod'"
      fi
    fi
  done

  echo
  echo "=== Verifying loaded CAN modules ==="
  lsmod | egrep "^can|^mttcan" || echo "No CAN-related modules found!"

  echo
  echo "=== Checking CAN interfaces ==="
  ip -details link show type can 2>/dev/null || echo "No CAN interfaces detected yet."

  echo
  echo "=== Turning on  can0 interface ==="
  ip link set can0 up type can bitrate 1000000
#+END_SRC

** Observe bus traffic (non-intrusive)

#+BEGIN_SRC bash :dir / :sudo yes :results output :exports both
  set -u

  IFACE="${IFACE:-can0}"          # override with: IFACE=can1
  DUR="${DUR:-5}"                 # seconds to observe
  LOG="/tmp/candump_${IFACE}_$(date +%F_%H%M%S).log"

  echo "=== CAN traffic observation (non-intrusive) ==="
  echo "[i] Interface : $IFACE"
  echo "[i] Duration  : ${DUR}s"

  # 1) Ensure candump is available (quiet install if missing)
  if ! command -v candump >/dev/null 2>&1; then
    echo "[..] Installing can-utils..."
    if sudo apt-get update -qq && sudo apt-get install -y -qq can-utils; then
      echo "[OK] can-utils installed"
    else
      echo "[ERR] Failed to install can-utils"; exit 1
    fi
  fi

  # 2) Inspect interface state (non-intrusive)
  if ip link show "$IFACE" >/dev/null 2>&1; then
    echo
    echo "=== Interface status ==="
    ip -details -brief link show "$IFACE"
  else
    echo "[ERR] Interface '$IFACE' not found"
    echo "     Hint: check your device tree/driver and interface name."
    exit 2
  fi

  # 3) Observe bus frames (no state changes performed)
  echo
  echo "=== Capturing traffic for ${DUR}s ==="
  # Absolute timestamps; suppress stderr noise if iface is down
  CAPTURE="$(timeout --preserve-status "${DUR}s" candump -t a "$IFACE" 2>/dev/null || true)"
  COUNT="$(printf "%s\n" "$CAPTURE" | sed '/^[[:space:]]*$/d' | wc -l | awk '{print $1}')"

  # 4) Save full capture and show a readable summary
  printf "%s\n" "$CAPTURE" > "$LOG"

  if [ "$COUNT" -gt 0 ]; then
    echo "[OK] Observed $COUNT frame(s) in ${DUR}s"
    echo
    echo "=== Sample (first 10 lines) ==="
    printf "%s\n" "$CAPTURE" | head -n 10
    echo
    echo "[i] Full capture saved to: $LOG"
  else
    echo "[WARN] No frames observed in ${DUR}s (bus may be idle)."
    echo "      - If the interface is DOWN, bring it up with your desired bitrate, e.g.:"
    echo "        sudo ip link set $IFACE up type can bitrate 1000000"
    echo "      - If using silent/loopback modes, ensure filters and mode are correct."
    echo "      - Check cabling/termination and that peers are transmitting."
  fi
#+END_SRC

** References
- NVIDIA Jetson CAN Guide (r35.3.1):    [[https://docs.nvidia.com/jetson/archives/r35.3.1/DeveloperGuide/text/HR/ControllerAreaNetworkCan.html]]
- Protocol background: [[https://en.wikipedia.org/wiki/ISO_15765-2][ISO 15765-2 (ISO-TP)]] | [[https://en.wikipedia.org/wiki/CANopen][CANopen]]

* I²C Devices — IDs & Minimal Reads

** Inventory (I²C buses with quick map & summary)

#+BEGIN_SRC bash :dir /sudo:: :results output :exports both
  # Readable I²C inventory + quick maps (non-intrusive, uses i2cdetect -r)
  # Tip: set MAX_LINES to control how many map lines to show (default: 12)
  MAX_LINES="${MAX_LINES:-12}"

  # 1) Preconditions
  if ! command -v i2cdetect >/dev/null 2>&1; then
    echo "ERROR: i2c-tools not installed (apt-get install -y i2c-tools)"
    exit 0
  fi

  # 2) Bus inventory table (sorted)
  echo "== I²C bus inventory =="
  sudo i2cdetect -l 2>/dev/null | sort -V | \
  awk '{
         # Drop the trailing "I2C adapter" (last 2 fields)
         n = NF-2; name=$3; for(i=4;i<=n;i++) name=name" "$i;
         printf "  %-6s %-8s  %s\n", $1, $2, name
       }'

  # 3) Per-bus map + concise summary
  echo ""
  echo "== Quick maps & summaries =="
  # Iterate using the inventory we just printed (ensures we only try real buses)
  while read -r line; do
    bus=$(awk "{print \$1}" <<<"$line")           # e.g., i2c-7
    [ -n "$bus" ] || continue
    busnum="${bus#i2c-}"
    [ -e "/dev/i2c-$busnum" ] || continue

    # Header with bus name (extract again for clarity)
    bname=$(awk '{
                   n = NF-2; name=$3; for(i=4;i<=n;i++) name=name" "$i;
                   print name
                 }' <<<"$line")
    printf "\nBus %s (%s):\n" "$busnum" "$bname"

    # Show a trimmed map (top MAX_LINES lines)
    sudo i2cdetect -y -r "$busnum" 2>/dev/null | sed -n "1,${MAX_LINES}p"

    # Build a summary of detected vs in-use (UU) addresses
    sudo i2cdetect -y -r "$busnum" 2>/dev/null | \
    awk 'NR==1{next}
         {
           # Row label like "30:" -> base address
           base=$1; sub(":","",base); base=strtonum("0x" base);
           for(i=2;i<=NF;i++){
             val=$i; if(val=="--") continue;
             addr = base + (i-2);
             hex  = sprintf("%02x", addr);
             if(val=="UU"){ used[hex]=1; u++ } else { found[hex]=1; d++ }
           }
         }
         END{
           if(d){
             printf "  Devices (%d):", d;
             for(a in found) printf " 0x%s", a; print ""
           } else print "  Devices: none"

           if(u){
             printf "  In-use (UU) (%d):", u;
             for(a in used) printf " 0x%s", a; print ""
           }
         }'
  done < <(sudo i2cdetect -l 2>/dev/null | sort -V)
#+END_SRC

** ADS7142 (NTC ADC) — bus 7 @ 0x1f (presence)

#+BEGIN_SRC bash :results output :exports both
  sudo i2cget -y 7 0x1f 2>/dev/null || echo "ADS7142 not responding at 0x1f on bus 7"
#+END_SRC

*Note:* A return like =0xff= confirms bus/address responds. (Optional functional temp read lives outside this doc.)

** HDC1080 (Temp/Humidity) — ID registers (word-swapped)

- Manufacturer ID register =0xFE= → expects =0x5449= ("TI")
- Device ID register =0xFF= → expects =0x1050= ("HDC1080")

#+BEGIN_SRC bash :results output :exports both
  echo "Manufacturer ID (0xFE):"
  sudo i2cget -y 7 0x40 0xfe w 2>/dev/null || true
  echo "Device ID (0xFF):"
  sudo i2cget -y 7 0x40 0xff w 2>/dev/null || true

#+END_SRC

*Note:* =0x4954= and =0x5010=, which are byte-swapped word reads matching TI/HDC1080.

** LIS2DE12 (Accel) — WHO_AM_I (0x0F → 0x33)

#+BEGIN_SRC bash :results output :exports both
  sudo i2cget -y 7 0x18 0x0f b 2>/dev/null || echo "LIS2DE12 WHO_AM_I read failed"
#+END_SRC

** AT24CS01 (EEPROM + Unique ID) — dump (non-destructive)

#+BEGIN_SRC bash :results output :exports both
  echo "EEPROM @0x50 (first 0x40 bytes):"
  sudo i2cdump -y 1 0x50 b 2>/dev/null | sed -n '1,6p' || true
  echo
  echo "Unique ID page (example @0x58):"
  sudo i2cdump -y 1 0x58 b 2>/dev/null | sed -n '1,8p' || true
#+END_SRC

** TPS25990 (eFuse) — ASCII signature block

#+BEGIN_SRC bash :results output :exports both
  sudo i2cdump -y 1 0x46 s 0x9a 2>/dev/null || echo "TPS25990 signature not found"
#+END_SRC

*Your example shows ASCII =TPS25990= in the dump.*

** GPIO Expanders

*** PCAL6408 — bus 1 @ 0x20 (Input Port 0 register 0x00)

#+BEGIN_SRC bash :results output :exports both
  sudo i2cget -y 1 0x20 0x00 b 2>/dev/null || echo "PCAL6408 not responding"
#+END_SRC

*** TCA9535 — bus 7 @ 0x20 (Input Port 0 register 0x00)

#+BEGIN_SRC bash :results output :exports both
  sudo i2cget -y 7 0x20 0x00 b 2>/dev/null || echo "TCA9535 not responding"
#+END_SRC


* SPI & TPM 2.0 (visibility)

** spidev nodes and TPM character device

#+BEGIN_SRC bash :results output :exports both
  ls -l /dev/spi* 2>/dev/null || echo "No /dev/spi*"
  ls -l /dev/tpm* 2>/dev/null || echo "No /dev/tpm*"
#+END_SRC

** Kernel binding (tpm_tis_spi or firmware TPM reference)

#+BEGIN_SRC bash :results output :exports both
  sudo dmesg | egrep -i "tpm|tpm_tis|spi" | tail -n 120
#+END_SRC

*Reference:* [[https://docs.nvidia.com/jetson/archives/r36.4/DeveloperGuide/SD/Security/FirmwareTPM.html][Firmware TPM — NVIDIA Jetson Linux Developer Guide.]]


* UART / TTY Nodes (recap)

#+BEGIN_SRC bash :results output :exports both
  ls -l /dev/ttyTHS* /dev/ttyS* /dev/ttyAMA* /dev/ttyUSB* /dev/ttyACM* 2>/dev/null || true
  dmesg | egrep -i "serial|ttyTHS|ttyS|ttyACM|ttyUSB" | tail -n 80
#+END_SRC

* Fans, Tach, and hwmon

** CPU Fan RPM (tachometer node)

#+BEGIN_SRC bash :results output :exports both
  cat /sys/devices/platform/39c0000.tachometer/hwmon/*/rpm 2>/dev/null || echo "CPU tach node not found"
#+END_SRC

** Cabinet Fan RPM & Temp Sensor (if exposed via hwmon)

#+BEGIN_SRC bash :results output :exports both
  for h in /sys/class/hwmon/hwmon*; do
      [ -e "$h" ] || continue
      echo "== $h ($(cat $h/name 2>/dev/null)) =="
      ls $h 2>/dev/null | egrep "temp[0-9]_input|fan[0-9]_input" | sed "s|^|  |"
  done
#+END_SRC

* Evidence (save logs/artifacts)
- Save outputs to =evidence/io_visibility/=:
  - =dmesg_io_tail.log=
  - =usb_ftdi_hub.log=
  - =i2c_map_bus1_bus7.txt=
  - =eeprom_at24_dump.txt=
  - =lis2de12_whoami.txt=
  - =hdc1080_ids.txt=
  - =tps25990_sig.txt=
  - =gpio_expanders_read.txt=
  - =tpm_spi_nodes.txt=
  - =tty_nodes.txt=
  - =hwmon_fans.txt=

* Troubleshooting (visibility only)

- *I²C device missing:* confirm bus number, power rail, and DT node; review pull-ups.
- *EEPROM UID page empty:* some lots lock UID; verify address (0x58 vs. vendor variant).
- *HDC1080 IDs byte-swapped:* =i2cget -w= returns words in LSB:MSB order; compare against 0x5449/0x1050.
- *LIS2DE12 WHO_AM_I ≠ 0x33:* check address variant or reset line.
- *FTDI missing:* re-seat USB, verify hub (0424:2514) enumerates, check cable.
- *TPM node absent:* ensure =tpm_tis_spi= or firmware TPM enabled in kernel/DT.

* Findings Log (NCR)

| ID | Subsystem | Node/Addr | Severity | Description | Evidence | Status |
|----+-----------+-----------+----------+-------------+----------+--------|
| 1  | I²C       | 7-0x18    | Major    | LIS2DE12 WHO_AM_I mismatch | [[file:evidence/io_visibility/lis2de12_whoami.txt]] | Open |
| 2  | USB/TTY   | ttyUSB?   | Minor    | RS-485 bridge not enumerated | [[file:evidence/io_visibility/usb_ftdi_hub.log]] | Open |

* Disposition

- [ ] PASS — all nodes visible and IDs readable
- [ ] FAIL — hold for DT/power/pinmux review and re-test

* Sign-off

| Role        | Name | Date | Signature |
|-------------+------+------+-----------|
| Operator    |      |      |           |
| QA Reviewer |      |      |           |

* Links
- [[file:00_INDEX.org][Back to Index]]
